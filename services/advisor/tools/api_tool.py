import asyncio
import json
import logging
import re
import os
from typing import Dict, List, Any, Optional, Union, Tuple, Type
from urllib.parse import urlencode, urlparse
from pathlib import Path

import httpx
from langchain.tools import BaseTool
from pydantic import BaseModel, Field, create_model, ValidationError

# Set up logging
logger = logging.getLogger(__name__)


class APIToolAutoScanner:
    """
    AUTOMATIC API Tool Scanner - HO√ÄN TO√ÄN ƒê·ªòNG!
    1. Qu√©t app_config.json ƒë·ªÉ t√¨m tools c√≥ type = "api_tool"
    2. T·ª± ƒë·ªông t·∫°o tools cho m·ªói API
    3. KH√îNG HARD-CODE g√¨ c·∫£ - t·∫•t c·∫£ t·ª´ config!
    """
    
    def __init__(self, config_path: str = None):
        # ‚úÖ T·ª∞ ƒê·ªòNG T√åM ƒê∆Ø·ªúNG D·∫™N CH√çNH X√ÅC
        if config_path is None:
            # T√¨m ƒë∆∞·ªùng d·∫´n t·ªõi app_config.json t·ª´ v·ªã tr√≠ hi·ªán t·∫°i
            current_file = Path(__file__)
            # ƒêi ng∆∞·ª£c l√™n 4 c·∫•p: tools -> advisor -> services -> root
            root_dir = current_file.parent.parent.parent.parent
            config_path = root_dir / "data" / "app_config.json"
        
        self.config_path = str(config_path)
        self.api_configs = self._scan_api_configs()
        logger.info(f"APIToolAutoScanner initialized with {len(self.api_configs)} API configurations")
        logger.info(f"Config path: {self.config_path}")
    
    def _scan_api_configs(self) -> Dict[str, Dict[str, Any]]:
        """Qu√©t t·ª± ƒë·ªông t·∫•t c·∫£ API configurations t·ª´ app_config.json"""
        try:
            # ‚úÖ KI·ªÇM TRA FILE T·ªíN T·∫†I
            if not os.path.exists(self.config_path):
                logger.error(f"Config file not found: {self.config_path}")
                logger.error(f"Current working directory: {os.getcwd()}")
                logger.error(f"File location: {__file__}")
                return {}
            
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            tools = config.get("agent_config", {}).get("tools", [])
            api_configs = {}
            
            for tool in tools:
                # ‚úÖ HO√ÄN TO√ÄN ƒê·ªòNG - L·∫§Y T·ª™ CONFIG!
                tool_type = tool.get("type", "")
                if tool_type == "api_tool":  # ƒê√öNG - L·∫§Y T·ª™ CONFIG!
                    api_name = tool.get("name", "unknown")
                    api_configs[api_name] = tool
                    logger.info(f"Found API tool config: {api_name} (type: {tool_type})")
                else:
                    logger.debug(f"Skipping tool {tool.get('name', 'unknown')} with type: {tool_type}")
            
            logger.info(f"Total API tools found: {len(api_configs)}")
            return api_configs
            
        except Exception as e:
            logger.error(f"Failed to scan API configs: {e}")
            logger.error(f"Config path: {self.config_path}")
            return {}
    
    def create_all_api_tools(self) -> List['AutoGeneratedAPITool']:
        """T·ª± ƒë·ªông t·∫°o tools cho T·∫§T C·∫¢ API ƒë√£ ph√°t hi·ªán"""
        tools = []
        
        for api_name, api_config in self.api_configs.items():
            try:
                logger.info(f"üîÑ Creating tool for {api_name}...")
                logger.debug(f"Config: {api_config}")
                
                tool = AutoGeneratedAPITool(api_config, self.config_path)
                tools.append(tool)
                logger.info(f"‚úÖ Auto-generated tool: {tool.name}")
                
            except Exception as e:
                logger.error(f"‚ùå Failed to create tool for {api_name}: {e}")
                logger.error(f"Config: {api_config}")
                import traceback
                logger.error(f"Traceback: {traceback.format_exc()}")
        
        logger.info(f"üéØ Total auto-generated tools: {len(tools)}")
        return tools
    
    def create_specific_api_tool(self, api_name: str) -> Optional['AutoGeneratedAPITool']:
        """T·∫°o tool cho m·ªôt API c·ª• th·ªÉ"""
        if api_name not in self.api_configs:
            logger.error(f"API '{api_name}' not found in scanned configs")
            return None
        
        try:
            return AutoGeneratedAPITool(self.api_configs[api_name], self.config_path)
        except Exception as e:
            logger.error(f"Failed to create tool for {api_name}: {e}")
            return None


class AutoGeneratedAPITool(BaseTool):
    """
    API Tool ƒë∆∞·ª£c t·∫°o T·ª∞ ƒê·ªòNG HO√ÄN TO√ÄN t·ª´ config!
    KH√îNG HARD-CODE g√¨ c·∫£ - t·∫•t c·∫£ t·ª´ app_config.json
    """
    
    def __init__(self, api_config: Dict[str, Any], config_path: str = None):
        # ‚úÖ L∆ØU CONFIG V√ÄO LOCAL VARIABLES TR∆Ø·ªöC
        self._api_config = api_config
        self._config_path = config_path
        
        # T·ª∞ ƒê·ªòNG T·∫†O t·∫•t c·∫£ properties
        self._auto_generate_all_properties()
        
        # Kh·ªüi t·∫°o HTTP client
        self._http_client = httpx.AsyncClient(timeout=30.0)
        
        # ‚úÖ G·ªåI CONSTRUCTOR CHA V·ªöI PROPERTIES ƒê√É T·∫†O
        super().__init__(
            name=self._generate_tool_name(),
            description=self._generate_tool_description(),
            args_schema=self._generate_input_schema()
        )
        
        logger.info(f"üöÄ Auto-generated tool '{self.name}' ready for use!")
    
    def _auto_generate_all_properties(self):
        """T·ª∞ ƒê·ªòNG T·∫†O t·∫•t c·∫£ tool properties t·ª´ config"""
        try:
            # L·∫§Y T·ª™ CONFIG - KH√îNG HARD-CODE!
            self._api_name = self._api_config.get("name", "unknown_api")
            self._api_type = self._api_config.get("type", "api_tool")  # ƒê√öNG!
            self._api_description = self._api_config.get("description", "API endpoint")
            
            # T·ª± ƒë·ªông tr√≠ch xu·∫•t c·∫•u tr√∫c input
            self._input_config = self._api_config.get("input", {})
            self._param_config = self._input_config.get("param", {})
            self._body_config = self._input_config.get("body", {})
            self._header_config = self._api_config.get("header", {})
            
            # T·ª± ƒë·ªông tr√≠ch xu·∫•t c·∫•u tr√∫c output
            self._output_config = self._api_config.get("output", {})
            
            # T·ª± ƒë·ªông tr√≠ch xu·∫•t curl ƒë·ªÉ l·∫•y URL v√† method
            self._curl_command = self._api_config.get("curl", "")
            
            logger.debug(f"‚úÖ Properties generated for {self._api_name}")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to generate properties: {e}")
            # Set defaults n·∫øu c√≥ l·ªói
            self._api_name = "unknown_api"
            self._api_type = "api_tool"
            self._api_description = "API endpoint"
            self._input_config = {}
            self._param_config = {}
            self._body_config = {}
            self._header_config = {}
            self._output_config = {}
            self._curl_command = ""
    
    def _generate_tool_name(self) -> str:
        """T·ª± ƒë·ªông t·∫°o t√™n tool duy nh·∫•t"""
        return self._api_name
    
    def _extract_url_from_curl(self) -> Optional[str]:
        """Extract the first HTTP(S) URL from the curl command robustly.
        - Prefer explicit http(s):// patterns anywhere in the string
        - Fallback to quoted segments that start with http(s)
        """
        try:
            curl = self._curl_command or ""
            if not curl:
                return None

            # Direct http(s) URL anywhere
            m = re.search(r"https?://[^\s'\"\\]+", curl)
            if m:
                return m.group(0)

            # Quoted http(s) URL
            m = re.search(r"['\"](https?://[^'\"]+)['\"]", curl)
            if m:
                return m.group(1)

            # Fallback: take the last quoted token that starts with http(s)
            quoted = re.findall(r"['\"]([^'\"]+)['\"]", curl)
            for token in reversed(quoted):
                if token.startswith("http://") or token.startswith("https://"):
                    return token
            return None
        except Exception:
            return None

    def _generate_tool_description(self) -> str:
        """T·ª± ƒë·ªông t·∫°o m√¥ t·∫£ theo chu·∫©n c·∫•u tr√∫c: r√µ r√†ng, c√≥ heading, bullet, v√≠ d·ª•"""
        try:
            parts: List[str] = []

            # Purpose
            desc = self._api_description or self._api_name
            parts.append(f"## Purpose")
            parts.append(desc)

            # Endpoint
            method = self._auto_detect_http_method()
            base_url = self._extract_url_from_curl()
            path = None
            if base_url:
                try:
                    parsed = urlparse(base_url)
                    path = parsed.path
                except Exception:
                    pass

            parts.append("\n## Endpoint")
            if method and (path or base_url):
                endpoint_value = path or base_url
                parts.append(f"- Method: {method}")
                parts.append(f"- Path: {endpoint_value}")
            elif method:
                parts.append(f"- Method: {method}")

            # Inputs
            if self._param_config or self._body_config:
                parts.append("\n## Inputs")

                # Query params (required first)
                if self._param_config:
                    param_keys = list(self._param_config.keys())
                    param_keys.sort(key=lambda k: (not self._param_config.get(k, {}).get("required", False), k))
                    parts.append("### Query Parameters")
                    for k in param_keys:
                        conf = self._param_config.get(k, {})
                        typ = conf.get("type", "string")
                        req = conf.get("required", False)
                        default = conf.get("default", None)
                        des = conf.get("description", "")
                        badge = "required" if req else "optional"
                        default_str = f", default={json.dumps(default, ensure_ascii=False)}" if default is not None else ""
                        line = f"- {k}: {typ} | {badge}{default_str}"
                        if des:
                            line += f" ‚Äî {des}"
                        parts.append(line)

                # Body fields (required first)
                if self._body_config:
                    body_keys = list(self._body_config.keys())
                    body_keys.sort(key=lambda k: (not self._body_config.get(k, {}).get("required", False), k))
                    parts.append("### Body Fields")
                    for k in body_keys:
                        conf = self._body_config.get(k, {})
                        typ = conf.get("type", "string")
                        req = conf.get("required", False)
                        default = conf.get("default", None)
                        des = conf.get("description", "")
                        badge = "required" if req else "optional"
                        default_str = f", default={json.dumps(default, ensure_ascii=False)}" if default is not None else ""
                        line = f"- {k}: {typ} | {badge}{default_str}"
                        if des:
                            line += f" ‚Äî {des}"
                        parts.append(line)

            # Headers
            if self._header_config:
                parts.append("\n## Headers (default)")
                for hk, hv in self._header_config.items():
                    parts.append(f"- {hk}: {hv}")

            # Example Request (limit to 3 fields/section)
            parts.append("\n## Example Request")
            ex_params: Dict[str, Any] = {}
            if self._param_config:
                for k in list(self._param_config.keys())[:3]:
                    val = self._auto_generate_example_value(self._param_config[k])
                    if isinstance(val, (dict, list)):
                        val = json.dumps(val, ensure_ascii=False)
                    ex_params[k] = val

            ex_body: Dict[str, Any] = {}
            if self._body_config:
                for k in list(self._body_config.keys())[:3]:
                    ex_body[k] = self._auto_generate_example_value(self._body_config[k])

            if method == "GET" and base_url:
                if ex_params:
                    qs = urlencode({k: str(v) for k, v in ex_params.items()})
                    sample = f"{base_url.split('?')[0]}?{qs}"
                else:
                    sample = base_url
                parts.append(f"- GET {sample}")
            elif method in ("POST", "PUT") and base_url:
                parts.append(f"- {method} {base_url}")
                if ex_body:
                    parts.append(f"- Body: {json.dumps(ex_body, ensure_ascii=False)}")
            else:
                if ex_params:
                    parts.append(f"- params: {json.dumps(ex_params, ensure_ascii=False)}")
                if ex_body:
                    parts.append(f"- body: {json.dumps(ex_body, ensure_ascii=False)}")

            # Response Fields
            fields = (self._output_config or {}).get("fields", [])
            if isinstance(fields, list) and fields:
                parts.append("\n## Response Fields")
                for f in fields[:10]:
                    key = f.get("key", "field")
                    typ = f.get("type", "any")
                    des = f.get("description", "")
                    line = f"- {key}: {typ}"
                    if des:
                        line += f" ‚Äî {des}"
                    parts.append(line)

            # Notes (concise guidance)
            notes: List[str] = []
            if self._param_config or self._body_config:
                notes.append("Provide all required fields; optional fields may be omitted.")
            if notes:
                parts.append("\n## Notes")
                for n in notes:
                    parts.append(f"- {n}")

            return "\n".join(parts)
        except Exception as e:
            logger.error(f"Failed to generate description: {e}")
            return self._api_description or self._api_name
    
    def _auto_detect_http_method(self) -> str:
        """T·ª± ƒë·ªông detect HTTP method t·ª´ curl command"""
        curl = self._curl_command.lower()
        if "-x 'put'" in curl or "-x put" in curl:
            return "PUT"
        elif "-x 'post'" in curl or "-x post" in curl:
            return "POST"
        elif "-x 'get'" in curl or "-x get" in curl:
            return "GET"
        elif "-x 'delete'" in curl or "-x delete" in curl:
            return "DELETE"
        else:
            return "GET"
    
    def _generate_input_schema(self) -> Type[BaseModel]:
        """T·ª± ƒë·ªông t·∫°o Pydantic input schema ho√†n ch·ªânh"""
        
        fields = {
            "api_call_description": (
                str, 
                Field(
                    description=f"Describe what you want to do with {self._api_name}",
                    example=f"Use {self._api_name} to perform the requested operation"
                )
            )
        }
        
        # T·ª∞ ƒê·ªòNG T·∫†O query parameter fields
        if self._param_config:
            for param_name, param_def in self._param_config.items():
                field_type = self._auto_map_type(param_def.get("type", "string"))
                field_description = param_def.get("description", f"Parameter: {param_name}")
                field_default = param_def.get("default")
                field_required = param_def.get("required", False)
                
                # T·ª± ƒë·ªông t·∫°o field v·ªõi smart defaults
                if field_default is not None:
                    fields[f"param_{param_name}"] = (
                        field_type,
                        Field(
                            default=field_default,
                            description=field_description,
                            example=field_default
                        )
                    )
                else:
                    fields[f"param_{param_name}"] = (
                        field_type,
                        Field(
                            description=field_description,
                            example=self._auto_generate_example(param_def)
                        )
                    )
        
        # T·ª∞ ƒê·ªòNG T·∫†O body fields
        if self._body_config:
            for body_name, body_def in self._body_config.items():
                field_type = self._auto_map_type(body_def.get("type", "string"))
                field_description = body_def.get("description", f"Body field: {body_name}")
                field_required = body_def.get("required", False)
                
                if field_required:
                    fields[f"body_{body_name}"] = (
                        field_type,
                        Field(
                            description=field_description,
                            example=self._auto_generate_example(body_def)
                        )
                    )
                else:
                    fields[f"body_{body_name}"] = (
                        field_type,
                        Field(
                            default=None,
                            description=field_description,
                            example=self._auto_generate_example(body_def)
                        )
                    )
        
        # T·ª∞ ƒê·ªòNG T·∫†O header override fields
        if self._header_config:
            for header_name, header_value in self._header_config.items():
                if header_name.lower() not in ['content-type', 'accept']:
                    fields[f"header_{header_name}"] = (
                        str,
                        Field(
                            default=header_value,
                            description=f"Override {header_name} header",
                            example=header_value
                        )
                    )
        
        # T·ª± ƒë·ªông t·∫°o model class
        model_name = f"{self._api_name.capitalize()}Input"
        return create_model(model_name, **fields)
    
    def _auto_map_type(self, config_type: str) -> Type:
        """T·ª± ƒë·ªông map config types sang Pydantic types"""
        type_mapping = {
            "string": str,
            "number": float,
            "integer": int,
            "boolean": bool,
            "array": List[str],
            "object": Dict[str, Any]
        }
        return type_mapping.get(config_type, str)
    
    def _auto_generate_example(self, field_def: Dict[str, Any]) -> Any:
        """T·ª± ƒë·ªông t·∫°o smart examples d·ª±a tr√™n field definition"""
        field_type = field_def.get("type", "string")
        field_name = field_def.get("name", "field")
        
        # Smart examples d·ª±a tr√™n field name v√† type
        if "id" in field_name.lower():
            return "ID_001"
        elif "name" in field_name.lower():
            return "Example Name"
        elif "email" in field_name.lower():
            return "user@example.com"
        elif "phone" in field_name.lower():
            return "+1234567890"
        elif "price" in field_name.lower() or "cost" in field_name.lower():
            return 100.0
        elif "quantity" in field_name.lower() or "count" in field_name.lower():
            return 5
        elif "date" in field_name.lower() or "time" in field_name.lower():
            return "2024-01-15"
        elif field_type == "boolean":
            return True
        elif field_type == "number":
            return 100.0
        elif field_type == "integer":
            return 100
        elif field_type == "array":
            return ["item1", "item2"]
        elif field_type == "object":
            return {"key": "value"}
        else:
            return "example_value"
    
    def _auto_generate_example_value(self, field_def: Dict[str, Any]) -> Any:
        """T·ª± ƒë·ªông t·∫°o example value cho field"""
        return self._auto_generate_example(field_def)
    
    def _auto_build_request(self, tool_input: Dict[str, Any]) -> Tuple[str, Dict[str, str], Optional[Dict[str, Any]]]:
        """T·ª± ƒë·ªông build HTTP request t·ª´ tool input"""

        # Extract URL robustly from curl
        base_url = self._extract_url_from_curl()
        if not base_url:
            raise ValueError("Could not auto-extract URL from curl command")

        # T·ª± ƒë·ªông build query parameters
        query_params = {}
        for key, value in tool_input.items():
            if key.startswith("param_") and value is not None:
                param_name = key[6:]  # Remove "param_" prefix
                query_params[param_name] = value

        # T·ª± ƒë·ªông th√™m query parameters v√†o URL
        if query_params:
            query_string = urlencode(query_params)
            separator = '&' if '?' in base_url else '?'
            base_url = f"{base_url}{separator}{query_string}"

        # T·ª± ƒë·ªông build headers
        headers = {}
        headers.update(self._header_config)  # Start with defaults

        # T·ª± ƒë·ªông override v·ªõi tool input
        for key, value in tool_input.items():
            if key.startswith("header_") and value is not None:
                header_name = key[7:]  # Remove "header_" prefix
                headers[header_name] = value

        # T·ª± ƒë·ªông build body
        body = None
        body_fields = {}
        for key, value in tool_input.items():
            if key.startswith("body_") and value is not None:
                body_name = key[5:]  # Remove "body_" prefix
                body_fields[body_name] = value

        if body_fields:
            body = body_fields

        return base_url, headers, body
    
    async def _auto_execute_api_call(self, url: str, headers: Dict[str, str], body: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """T·ª± ƒë·ªông execute HTTP request v·ªõi detected method"""
        method = self._auto_detect_http_method()
        
        try:
            if method == "GET":
                response = await self._http_client.get(url, headers=headers)
            elif method == "POST":
                response = await self._http_client.post(url, headers=headers, json=body)
            elif method == "PUT":
                response = await self._http_client.put(url, headers=headers, json=body)
            elif method == "DELETE":
                response = await self._http_client.delete(url, headers=headers)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            response.raise_for_status()
            
            # T·ª± ƒë·ªông parse response
            try:
                response_data = response.json()
            except:
                response_data = response.text
            
            return {
                "success": True,
                "status_code": response.status_code,
                "method": method,
                "url": url,
                "data": response_data,
                "headers": dict(response.headers)
            }
            
        except httpx.HTTPStatusError as e:
            return {
                "success": False,
                "status_code": e.response.status_code,
                "method": method,
                "url": url,
                "error": f"HTTP {e.response.status_code}: {e.response.text}"
            }
        except Exception as e:
            return {
                "success": False,
                "method": method,
                "url": url,
                "error": str(e)
            }
    
    def _auto_format_response(self, response: Dict[str, Any]) -> str:
        """T·ª± ƒë·ªông format API response"""
        if not response.get("success"):
            return f"‚ùå API call failed: {response.get('error', 'Unknown error')}"
        
        # T·ª± ƒë·ªông format successful response
        output = [
            f"‚úÖ {self._api_name} API call successful!",
            f"üåê Method: {response.get('method', 'N/A')}",
            f"üì° Status: {response.get('status_code', 'N/A')}",
            f" URL: {response.get('url', 'N/A')}",
            "",
            "üìä Response Data:"
        ]
        
        data = response.get("data", {})
        if isinstance(data, dict):
            for key, value in data.items():
                if isinstance(value, (dict, list)):
                    output.append(f"  {key}: {json.dumps(value, indent=2, ensure_ascii=False)}")
                else:
                    output.append(f"  {key}: {value}")
        else:
            output.append(f"  {data}")
        
        return "\n".join(output)
    
    async def _arun(self, **kwargs) -> str:
        """T·ª± ƒë·ªông execute API call"""
        try:
            # T·ª± ƒë·ªông build request
            url, headers, body = self._auto_build_request(kwargs)
            
            # T·ª± ƒë·ªông execute API call
            response = await self._auto_execute_api_call(url, headers, body)
            
            # T·ª± ƒë·ªông format response
            return self._auto_format_response(response)
            
        except Exception as e:
            logger.error(f"Auto-generated API tool execution failed: {e}")
            return f"‚ùå {self._api_name} API tool execution failed: {str(e)}"
    
    def _run(self, **kwargs) -> str:
        """Synchronous wrapper"""
        return asyncio.run(self._arun(**kwargs))
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self._http_client.aclose()
    
    def __del__(self):
        """T·ª± ƒë·ªông cleanup"""
        try:
            asyncio.create_task(self._http_client.aclose())
        except:
            pass


# Convenience functions cho d·ªÖ t√≠ch h·ª£p
def create_auto_api_tools(config_path: str = None) -> List[AutoGeneratedAPITool]:
    """T·∫°o t·∫•t c·∫£ auto-generated API tools"""
    scanner = APIToolAutoScanner(config_path)
    return scanner.create_all_api_tools()


def create_auto_api_tool(api_name: str, config_path: str = None) -> Optional[AutoGeneratedAPITool]:
    """T·∫°o m·ªôt auto-generated API tool c·ª• th·ªÉ"""
    scanner = APIToolAutoScanner(config_path)
    return scanner.create_specific_api_tool(api_name)


# Example usage v√† testing
if __name__ == "__main__":
    async def test_auto_generation():
        """Test h·ªá th·ªëng auto-generation"""
        
        print("üöÄ Testing APIToolAutoScanner...")
        print(f"Current working directory: {os.getcwd()}")
        print(f"File location: {__file__}")
        
        try:
            # T·∫°o t·∫•t c·∫£ tools t·ª± ƒë·ªông
            all_tools = create_auto_api_tools()
            print(f"‚úÖ Auto-generated {len(all_tools)} tools:")
            
            for tool in all_tools:
                print(f"\nüîß Tool: {tool.name}")
                print(f" Description: {tool.description[:150]}...")
                print(f"üìä Input Schema: {tool.args_schema.__name__}") 
                
                # ‚úÖ S·ª¨A L·ªñI PYDANTIC V2 - S·ª¨ D·ª§NG model_fields
                if hasattr(tool.args_schema, 'model_fields'):
                    print("üìã Auto-generated Input Fields:")
                    for field_name, field_info in tool.args_schema.model_fields.items():
                        # ‚úÖ S·ª¨A L·ªñI - S·ª¨ D·ª§NG annotation thay v√¨ type_
                        field_type = field_info.annotation
                        print(f"  - {field_name}: {field_type} (default: {field_info.default})")
                # Fallback cho Pydantic V1
                elif hasattr(tool.args_schema, '__fields__'):
                    print("üìã Auto-generated Input Fields (Pydantic V1):")
                    for field_name, field_info in tool.args_schema.__fields__.items():
                        field_type = field_info.type_
                        print(f"  - {field_name}: {field_type} (default: {field_info.default})")
            
            # Test specific tool
            if all_tools:
                test_tool = all_tools[0]
                print(f"\n Testing first tool: {test_tool.name}")
                print(f"Name: {test_tool.name}")
                print(f"Description: {test_tool.description[:200]}...")
            else:
                print("\n‚ùå No tools generated. Check config file and structure.")
                
        except Exception as e:
            print(f"‚ùå Test failed with error: {e}")
            import traceback
            print(f"Traceback: {traceback.format_exc()}")
    
    # Run test
    asyncio.run(test_auto_generation()) 