import asyncio
import json
import logging
import re
from typing import Dict, List, Any, Optional, Union, Tuple, Type
from urllib.parse import urlencode, urlparse

import httpx
from langchain.tools import BaseTool
from pydantic import BaseModel, Field, create_model, ValidationError

# Set up logging
logger = logging.getLogger(__name__)


class APIToolAutoScanner:
    """
    AUTOMATIC API Tool Scanner - HO√ÄN TO√ÄN ƒê·ªòNG!
    1. Qu√©t app_config.json ƒë·ªÉ t√¨m tools c√≥ type = "api_tool"
    2. T·ª± ƒë·ªông t·∫°o tools cho m·ªói API
    3. KH√îNG HARD-CODE g√¨ c·∫£ - t·∫•t c·∫£ t·ª´ config!
    """
    
    def __init__(self, config_path: str = "data/app_config.json"):
        self.config_path = config_path
        self.api_configs = self._scan_api_configs()
        logger.info(f"APIToolAutoScanner initialized with {len(self.api_configs)} API configurations")
    
    def _scan_api_configs(self) -> Dict[str, Dict[str, Any]]:
        """Qu√©t t·ª± ƒë·ªông t·∫•t c·∫£ API configurations t·ª´ app_config.json"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            tools = config.get("agent_config", {}).get("tools", [])
            api_configs = {}
            
            for tool in tools:
                # ‚úÖ HO√ÄN TO√ÄN ƒê·ªòNG - L·∫§Y T·ª™ CONFIG!
                tool_type = tool.get("type", "")
                if tool_type == "api_tool":  # ƒê√öNG - L·∫§Y T·ª™ CONFIG!
                    api_name = tool.get("name", "unknown")
                    api_configs[api_name] = tool
                    logger.info(f"Found API tool config: {api_name} (type: {tool_type})")
                else:
                    logger.debug(f"Skipping tool {tool.get('name', 'unknown')} with type: {tool_type}")
            
            logger.info(f"Total API tools found: {len(api_configs)}")
            return api_configs
            
        except Exception as e:
            logger.error(f"Failed to scan API configs: {e}")
            return {}
    
    def create_all_api_tools(self) -> List['AutoGeneratedAPITool']:
        """T·ª± ƒë·ªông t·∫°o tools cho T·∫§T C·∫¢ API ƒë√£ ph√°t hi·ªán"""
        tools = []
        
        for api_name, api_config in self.api_configs.items():
            try:
                tool = AutoGeneratedAPITool(api_config, self.config_path)
                tools.append(tool)
                logger.info(f"‚úÖ Auto-generated tool: {tool.name}")
            except Exception as e:
                logger.error(f"‚ùå Failed to create tool for {api_name}: {e}")
        
        logger.info(f"üéØ Total auto-generated tools: {len(tools)}")
        return tools
    
    def create_specific_api_tool(self, api_name: str) -> Optional['AutoGeneratedAPITool']:
        """T·∫°o tool cho m·ªôt API c·ª• th·ªÉ"""
        if api_name not in self.api_configs:
            logger.error(f"API '{api_name}' not found in scanned configs")
            return None
        
        try:
            return AutoGeneratedAPITool(self.api_configs[api_name], self.config_path)
        except Exception as e:
            logger.error(f"Failed to create tool for {api_name}: {e}")
            return None


class AutoGeneratedAPITool(BaseTool):
    """
    API Tool ƒë∆∞·ª£c t·∫°o T·ª∞ ƒê·ªòNG HO√ÄN TO√ÄN t·ª´ config!
    KH√îNG HARD-CODE g√¨ c·∫£ - t·∫•t c·∫£ t·ª´ app_config.json
    """
    
    def __init__(self, api_config: Dict[str, Any], config_path: str = "data/app_config.json"):
        # L∆∞u config ƒë·ªÉ t·∫°o ƒë·ªông
        self.api_config = api_config
        self.config_path = config_path
        
        # T·ª∞ ƒê·ªòNG T·∫†O t·∫•t c·∫£ properties
        self._auto_generate_all_properties()
        
        # Kh·ªüi t·∫°o HTTP client
        self.http_client = httpx.AsyncClient(timeout=30.0)
        
        # G·ªçi constructor cha v·ªõi properties ƒë∆∞·ª£c t·∫°o T·ª∞ ƒê·ªòNG
        super().__init__(
            name=self._generate_tool_name(),
            description=self._generate_tool_description(),
            args_schema=self._generate_input_schema()
        )
        
        logger.info(f"üöÄ Auto-generated tool '{self.name}' ready for use!")
    
    def _auto_generate_all_properties(self):
        """T·ª∞ ƒê·ªòNG T·∫†O t·∫•t c·∫£ tool properties t·ª´ config"""
        # L·∫§Y T·ª™ CONFIG - KH√îNG HARD-CODE!
        self.api_name = self.api_config.get("name", "unknown_api")
        self.api_type = self.api_config.get("type", "api_tool")  # ƒê√öNG!
        self.api_description = self.api_config.get("description", "API endpoint")
        
        # T·ª± ƒë·ªông tr√≠ch xu·∫•t c·∫•u tr√∫c input
        self.input_config = self.api_config.get("input", {})
        self.param_config = self.input_config.get("param", {})
        self.body_config = self.input_config.get("body", {})
        self.header_config = self.api_config.get("header", {})
        
        # T·ª± ƒë·ªông tr√≠ch xu·∫•t c·∫•u tr√∫c output
        self.output_config = self.api_config.get("output", {})
        
        # T·ª± ƒë·ªông tr√≠ch xu·∫•t curl ƒë·ªÉ l·∫•y URL v√† method
        self.curl_command = self.api_config.get("curl", "")
    
    def _generate_tool_name(self) -> str:
        """T·ª± ƒë·ªông t·∫°o t√™n tool duy nh·∫•t"""
        return f"api_{self.api_name}"
    
    def _generate_tool_description(self) -> str:
        """T·ª± ƒë·ªông t·∫°o m√¥ t·∫£ chi ti·∫øt t·ª´ config"""
        description_parts = []
        
        # M√¥ t·∫£ c∆° b·∫£n t·ª´ config
        description_parts.append(f"üîó {self.api_description}")
        
        # T·ª± ƒë·ªông ƒë·∫øm parameters
        if self.param_config:
            param_count = len(self.param_config)
            description_parts.append(f"üìä Query Parameters: {param_count}")
            
            # T·ª± ƒë·ªông li·ªát k√™ key parameters
            key_params = list(self.param_config.keys())[:3]
            if key_params:
                description_parts.append(f"   Key params: {', '.join(key_params)}")
        
        # T·ª± ƒë·ªông ƒë·∫øm body fields
        if self.body_config:
            body_count = len(self.body_config)
            description_parts.append(f" Body Fields: {body_count}")
            
            # T·ª± ƒë·ªông li·ªát k√™ required fields
            required_fields = [name for name, config in self.body_config.items() 
                             if config.get("required", False)]
            if required_fields:
                description_parts.append(f"   Required: {', '.join(required_fields)}")
        
        # T·ª± ƒë·ªông detect HTTP method
        method = self._auto_detect_http_method()
        description_parts.append(f"üåê Method: {method}")
        
        # T·ª± ƒë·ªông t·∫°o usage examples
        description_parts.append("\n Usage Examples:")
        
        # T·∫°o example cho query params
        if self.param_config:
            example_param = next(iter(self.param_config.keys()))
            example_value = self._auto_generate_example_value(self.param_config[example_param])
            description_parts.append(f"   Query: {example_param}={example_value}")
        
        # T·∫°o example cho body
        if self.body_config:
            example_body = next(iter(self.body_config.keys()))
            example_value = self._auto_generate_example_value(self.body_config[example_body])
            description_parts.append(f"   Body: {example_body}: {example_value}")
        
        return "\n".join(description_parts)
    
    def _auto_detect_http_method(self) -> str:
        """T·ª± ƒë·ªông detect HTTP method t·ª´ curl command"""
        curl = self.curl_command.lower()
        if "-x 'put'" in curl or "-x put" in curl:
            return "PUT"
        elif "-x 'post'" in curl or "-x post" in curl:
            return "POST"
        elif "-x 'get'" in curl or "-x get" in curl:
            return "GET"
        elif "-x 'delete'" in curl or "-x delete" in curl:
            return "DELETE"
        else:
            return "GET"
    
    def _generate_input_schema(self) -> Type[BaseModel]:
        """T·ª± ƒë·ªông t·∫°o Pydantic input schema ho√†n ch·ªânh"""
        
        fields = {
            "api_call_description": (
                str, 
                Field(
                    description=f"Describe what you want to do with {self.api_name}",
                    example=f"Use {self.api_name} to perform the requested operation"
                )
            )
        }
        
        # T·ª∞ ƒê·ªòNG T·∫†O query parameter fields
        if self.param_config:
            for param_name, param_def in self.param_config.items():
                field_type = self._auto_map_type(param_def.get("type", "string"))
                field_description = param_def.get("description", f"Parameter: {param_name}")
                field_default = param_def.get("default")
                field_required = param_def.get("required", False)
                
                # T·ª± ƒë·ªông t·∫°o field v·ªõi smart defaults
                if field_default is not None:
                    fields[f"param_{param_name}"] = (
                        field_type,
                        Field(
                            default=field_default,
                            description=field_description,
                            example=field_default
                        )
                    )
                else:
                    fields[f"param_{param_name}"] = (
                        field_type,
                        Field(
                            description=field_description,
                            example=self._auto_generate_example(param_def)
                        )
                    )
        
        # T·ª∞ ƒê·ªòNG T·∫†O body fields
        if self.body_config:
            for body_name, body_def in self.body_config.items():
                field_type = self._auto_map_type(body_def.get("type", "string"))
                field_description = body_def.get("description", f"Body field: {body_name}")
                field_required = body_def.get("required", False)
                
                if field_required:
                    fields[f"body_{body_name}"] = (
                        field_type,
                        Field(
                            description=field_description,
                            example=self._auto_generate_example(body_def)
                        )
                    )
                else:
                    fields[f"body_{body_name}"] = (
                        field_type,
                        Field(
                            default=None,
                            description=field_description,
                            example=self._auto_generate_example(body_def)
                        )
                    )
        
        # T·ª∞ ƒê·ªòNG T·∫†O header override fields
        if self.header_config:
            for header_name, header_value in self.header_config.items():
                if header_name.lower() not in ['content-type', 'accept']:
                    fields[f"header_{header_name}"] = (
                        str,
                        Field(
                            default=header_value,
                            description=f"Override {header_name} header",
                            example=header_value
                        )
                    )
        
        # T·ª± ƒë·ªông t·∫°o model class
        model_name = f"{self.api_name.capitalize()}Input"
        return create_model(model_name, **fields)
    
    def _auto_map_type(self, config_type: str) -> Type:
        """T·ª± ƒë·ªông map config types sang Pydantic types"""
        type_mapping = {
            "string": str,
            "number": float,
            "integer": int,
            "boolean": bool,
            "array": List[str],
            "object": Dict[str, Any]
        }
        return type_mapping.get(config_type, str)
    
    def _auto_generate_example(self, field_def: Dict[str, Any]) -> Any:
        """T·ª± ƒë·ªông t·∫°o smart examples d·ª±a tr√™n field definition"""
        field_type = field_def.get("type", "string")
        field_name = field_def.get("name", "field")
        
        # Smart examples d·ª±a tr√™n field name v√† type
        if "id" in field_name.lower():
            return "ID_001"
        elif "name" in field_name.lower():
            return "Example Name"
        elif "email" in field_name.lower():
            return "user@example.com"
        elif "phone" in field_name.lower():
            return "+1234567890"
        elif "price" in field_name.lower() or "cost" in field_name.lower():
            return 100.0
        elif "quantity" in field_name.lower() or "count" in field_name.lower():
            return 5
        elif "date" in field_name.lower() or "time" in field_name.lower():
            return "2024-01-15"
        elif field_type == "boolean":
            return True
        elif field_type == "number":
            return 100.0
        elif field_type == "integer":
            return 100
        elif field_type == "array":
            return ["item1", "item2"]
        elif field_type == "object":
            return {"key": "value"}
        else:
            return "example_value"
    
    def _auto_generate_example_value(self, field_def: Dict[str, Any]) -> Any:
        """T·ª± ƒë·ªông t·∫°o example value cho field"""
        return self._auto_generate_example(field_def)
    
    def _auto_build_request(self, tool_input: Dict[str, Any]) -> Tuple[str, Dict[str, str], Optional[Dict[str, Any]]]:
        """T·ª± ƒë·ªông build HTTP request t·ª´ tool input"""
        
        # T·ª± ƒë·ªông tr√≠ch xu·∫•t URL t·ª´ curl
        url_match = re.search(r"'([^']+)'", self.curl_command)
        if not url_match:
            raise ValueError("Could not auto-extract URL from curl command")
        
        base_url = url_match.group(1)
        
        # T·ª± ƒë·ªông build query parameters
        query_params = {}
        for key, value in tool_input.items():
            if key.startswith("param_") and value is not None:
                param_name = key[6:]  # Remove "param_" prefix
                query_params[param_name] = value
        
        # T·ª± ƒë·ªông th√™m query parameters v√†o URL
        if query_params:
            query_string = urlencode(query_params)
            separator = '&' if '?' in base_url else '?'
            base_url = f"{base_url}{separator}{query_string}"
        
        # T·ª± ƒë·ªông build headers
        headers = {}
        headers.update(self.header_config)  # Start with defaults
        
        # T·ª± ƒë·ªông override v·ªõi tool input
        for key, value in tool_input.items():
            if key.startswith("header_") and value is not None:
                header_name = key[7:]  # Remove "header_" prefix
                headers[header_name] = value
        
        # T·ª± ƒë·ªông build body
        body = None
        body_fields = {}
        for key, value in tool_input.items():
            if key.startswith("body_") and value is not None:
                body_name = key[5:]  # Remove "body_" prefix
                body_fields[body_name] = value
        
        if body_fields:
            body = body_fields
        
        return base_url, headers, body
    
    async def _auto_execute_api_call(self, url: str, headers: Dict[str, str], body: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """T·ª± ƒë·ªông execute HTTP request v·ªõi detected method"""
        method = self._auto_detect_http_method()
        
        try:
            if method == "GET":
                response = await self.http_client.get(url, headers=headers)
            elif method == "POST":
                response = await self.http_client.post(url, headers=headers, json=body)
            elif method == "PUT":
                response = await self.http_client.put(url, headers=headers, json=body)
            elif method == "DELETE":
                response = await self.http_client.delete(url, headers=headers)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            response.raise_for_status()
            
            # T·ª± ƒë·ªông parse response
            try:
                response_data = response.json()
            except:
                response_data = response.text
            
            return {
                "success": True,
                "status_code": response.status_code,
                "method": method,
                "url": url,
                "data": response_data,
                "headers": dict(response.headers)
            }
            
        except httpx.HTTPStatusError as e:
            return {
                "success": False,
                "status_code": e.response.status_code,
                "method": method,
                "url": url,
                "error": f"HTTP {e.response.status_code}: {e.response.text}"
            }
        except Exception as e:
            return {
                "success": False,
                "method": method,
                "url": url,
                "error": str(e)
            }
    
    def _auto_format_response(self, response: Dict[str, Any]) -> str:
        """T·ª± ƒë·ªông format API response"""
        if not response.get("success"):
            return f"‚ùå API call failed: {response.get('error', 'Unknown error')}"
        
        # T·ª± ƒë·ªông format successful response
        output = [
            f"‚úÖ {self.api_name} API call successful!",
            f"üåê Method: {response.get('method', 'N/A')}",
            f"üì° Status: {response.get('status_code', 'N/A')}",
            f" URL: {response.get('url', 'N/A')}",
            "",
            "üìä Response Data:"
        ]
        
        data = response.get("data", {})
        if isinstance(data, dict):
            for key, value in data.items():
                if isinstance(value, (dict, list)):
                    output.append(f"  {key}: {json.dumps(value, indent=2, ensure_ascii=False)}")
                else:
                    output.append(f"  {key}: {value}")
        else:
            output.append(f"  {data}")
        
        return "\n".join(output)
    
    async def _arun(self, **kwargs) -> str:
        """T·ª± ƒë·ªông execute API call"""
        try:
            # T·ª± ƒë·ªông build request
            url, headers, body = self._auto_build_request(kwargs)
            
            # T·ª± ƒë·ªông execute API call
            response = await self._auto_execute_api_call(url, headers, body)
            
            # T·ª± ƒë·ªông format response
            return self._auto_format_response(response)
            
        except Exception as e:
            logger.error(f"Auto-generated API tool execution failed: {e}")
            return f"‚ùå {self.api_name} API tool execution failed: {str(e)}"
    
    def _run(self, **kwargs) -> str:
        """Synchronous wrapper"""
        return asyncio.run(self._arun(**kwargs))
    
    async def __aenter__(self):
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.http_client.aclose()
    
    def __del__(self):
        """T·ª± ƒë·ªông cleanup"""
        try:
            asyncio.create_task(self.http_client.aclose())
        except:
            pass


# Convenience functions cho d·ªÖ t√≠ch h·ª£p
def create_auto_api_tools(config_path: str = "data/app_config.json") -> List[AutoGeneratedAPITool]:
    """T·∫°o t·∫•t c·∫£ auto-generated API tools"""
    scanner = APIToolAutoScanner(config_path)
    return scanner.create_all_api_tools()


def create_auto_api_tool(api_name: str, config_path: str = "data/app_config.json") -> Optional[AutoGeneratedAPITool]:
    """T·∫°o m·ªôt auto-generated API tool c·ª• th·ªÉ"""
    scanner = APIToolAutoScanner(config_path)
    return scanner.create_specific_api_tool(api_name)


# Example usage v√† testing
if __name__ == "__main__":
    async def test_auto_generation():
        """Test h·ªá th·ªëng auto-generation"""
        
        print("üöÄ Testing APIToolAutoScanner...")
        
        # T·∫°o t·∫•t c·∫£ tools t·ª± ƒë·ªông
        all_tools = create_auto_api_tools()
        print(f"‚úÖ Auto-generated {len(all_tools)} tools:")
        
        for tool in all_tools:
            print(f"\nüîß Tool: {tool.name}")
            print(f" Description: {tool.description[:150]}...")
            print(f"üìä Input Schema: {tool.args_schema.__name__}")
            
            # Show auto-generated input fields
            if hasattr(tool.args_schema, '__fields__'):
                print("üìã Auto-generated Input Fields:")
                for field_name, field_info in tool.args_schema.__fields__.items():
                    print(f"  - {field_name}: {field_info.type_} (default: {field_info.default})")
        
        # Test specific tool
        if all_tools:
            test_tool = all_tools[0]
            print(f"\n Testing first tool: {test_tool.name}")
            print(f"Name: {test_tool.name}")
            print(f"Description: {test_tool.description[:200]}...")
    
    # Run test
    asyncio.run(test_auto_generation()) 